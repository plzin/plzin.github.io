import fs from 'fs'
import path from 'path'
import matter from 'gray-matter'
import { unified } from 'unified'
import remarkParse from 'remark-parse/lib'
import remarkRehype from 'remark-rehype'
import rehypeRaw from 'rehype-raw'
import rehypeSanitize from 'rehype-sanitize'
import rehypeStringify from 'rehype-stringify/lib'

// The directory where the posts are stored.
const postsDirectory = path.join(process.cwd(), 'posts')

let re_inline = /(?<!\\)\$(.*)(?<!\\)\$/g
let re_newline = /(?<!\\)\$\$(.*)(?<!\\)\$\$/g
let dollar = /\\$/g

function replace_latex_inline(mj, s) {
    return s.replaceAll(re_inline, (m, p, o, s, n) => {
        let svg = mj.tex2svg(p, { display: true })
        return mj.startup.adaptor.innerHTML(svg)
    })
}

// Returns the data about all posts sorted by date.
// Used by the home page to display a list of posts.
export async function getSortedPostsData() {
    // Load MathJax in case a title contains latex.
    let mj = await require('mathjax').init({
        loader: { load: ['input/tex', 'output/svg'] }
    })

    // Get the file names under /posts.
    const fileNames = fs.readdirSync(postsDirectory)
    const allPostsData = fileNames.map(fileName => {
        // Remove ".md" from the file name to get the ID.
        const id = fileName.replace(/\.md$/, '')

        // Read the markdown file as a string.
        const fullPath = path.join(postsDirectory, fileName)
        const fileContents = fs.readFileSync(fullPath, 'utf8')

        // Use gray-matter to parse the post metadata section.
        let matterResult = matter(fileContents)
        let data = matterResult.data
        data.title = replace_latex_inline(mj, data.title)
            .replaceAll(dollar, '$')

        // Combine the data with the ID.
        return {
            id,
            ...matterResult.data
        }
    })

    // Sort the posts by date.
    return allPostsData.sort(({ date: a }, { date: b }) => {
        if (a < b) { return 1 } else if (a > b) { return -1 } else { return 0 }
    })
}

export function getAllPostIds() {
    const fileNames = fs.readdirSync(postsDirectory)

    return fileNames.map(fileName => {
        return {
            params: {
                id: fileName.replace(/\.md$/, '')
            }
        }
    })
}

export async function getPostData(id) {
    const fullPath = path.join(postsDirectory, `${id}.md`)
    const fileContents = fs.readFileSync(fullPath, 'utf8')

    // Use gray-matter to parse the post metadata section.
    const matterResult = matter(fileContents)

    let mj = await require('mathjax').init({
        loader: { load: ['input/tex', 'output/svg'] }
    })

    matterResult.data.title = replace_latex_inline(mj, matterResult.data.title)
    let content = matterResult.content

    content = content.replaceAll(re_newline, (m, p, o, s, n) => {
        let svg = mj.tex2svg(p, { display: true })
        svg.children[0].attributes.width = '100%'
        return `<br />${mj.startup.adaptor.innerHTML(svg)}<br />`
    })

    content = replace_latex_inline(mj, content)

    // Replace the escaped dollars with actual ones.
    content = content.replaceAll(dollar, '$')

    // Use remark to convert the markdown into an HTML string.
    const processedContent = await unified()
        .use(remarkParse)
        .use(remarkRehype, { allowDangerousHtml: true })
        .use(rehypeRaw)
        //.use(rehypeSanitize) // This removes the SVGs generated by MathJax.
        .use(rehypeStringify)
        .process(content)
    const contentHtml = processedContent.toString()

    // Combine the data with the ID.
    return {
        id,
        contentHtml,
        ...matterResult.data
    }
}